一：内容介绍
    1.两周写一个公链的项目，是在一个外国人写一个开源项目上做的改造。他有些东西不全，
    比如几个区块里可以有多笔交易，它没有。包括终端中多笔交易打包到一个区块中，一致性协议等。
    但是远远没有比特笔复杂。我们了解公链的原理，实现一个简单的公链。
    我们能够了解
        block，
        blockchain，
        POW，
        数据库的存储，
        UTXO(为花费交易模型)
        Transaction，彼特币是10分钟打包一个区块，里面有多笔交易。
        地址，公钥，私钥，数字签名，验证签名：使用加密算法(sha256,ripemd160,椭圆加密)
        网络：节点A，节点B，节点C。。节点之间
            创建钱包，能转账，查询余额

            节点之间数据同步：
    2.区块链和彼特币简单介绍
        A：起源
            最早起源是2008年美国的一场金融危机，美国政府无限增发货币(记账权)。
            中本聪在当年10月发表一片文章《bitcoin：A peer to peer electronic cash system》(一种对等电子现金系统)，
            描述了一种电子货币及其算法。整体思想时开创性的。但是技术时已经存在的。p2p、分布式存储、Hash算法、非对称加密等。

        B：比特币
            在2009年1月3日，中本聪开发出首个实现了比特币算法的客户端程序并进行了首次"采矿"(mining)。
            北京时间2009年1月4日，比特币的第一个区块，就是创世区块。

            每个区块的产生后，比特币系统就会对挖矿者进行奖励。
            中本聪获得了第一批比特币50个。挖矿奖励比特币数不是固定的，每产生21万个区块，奖励就减半。

                比特币系统规定每10分钟产生一个区块，算下来就是每4年奖励就会减半。预计

                比特币：一共2100万个
                	2008年开始，2012年奖励50个
                	2012年开始，2016年奖励25个
                	2016年开始，2020年奖励12.5个




            第一个区块中，并没有交易记录。而是将《泰晤士报》2009年1月3日的一条新闻永远记录在了其中。
            前十万个区块中：中本聪自己挖矿，coinbase交易，系统奖励金币的交易。

        C：挖矿
            挖矿时重复计算区块头的hash，不断修改随机数nonce，指导与难度目标值匹配。
            挖矿就是在争取记账权，对一段时间内比特币网络中的交易进行确认，并记录在区块链上的过程。
                矿工时记账员，区块链是账本，每个区块就是整个账本中的每一个账页。
            挖矿成功，矿工争取到了区块的记账权，这10分钟内被打包的所有未确认的交易的手续费都会奖励给该矿工

        D：区块链的流程
            区块链，就是一种分布式，不保存到数据库，以文本的形式保存。保存到每一台加入比特币网络的，只要安装了比特币钱包，
            就可以保存。
            某个节点要做交易，全节点，轻节点(钱包节点，矿工节点)，只保存自己的交易记录。

            500万个用户，几万个全节点。全节点不能关机(安装了比特币客户端，并且下载了20个G就被认为是全节点)，关机被认为是劣质节点。

            比特币的思想：人人为我，我为人人。
            中本聪世界乌托邦的大同世界。

        E：区块和区块链

        F：区块链：公链，私链，联盟链


二：本堂课内容
1.基本原型
    A：
        step1：block结构体，
        step2：创建新区块，
        step3：设置哈希
    Block结构体
        字段：
            高度Height：其实就是区块的编号，第一个区块叫创世区块，高度为0
            上一个区块的哈希值ProvHash：
            交易数据Data：目前先设计为[]byte,后期是Transaction
            时间戳TimeStamp：
            哈希值Hash：

    bit：1个0或1
    byte：8个bit
    1024byte：1kb
    1024kb：1mb
    。。。

    16进制：1111,4个bit
        2个16进制数，也是一个byte。


    设置哈希值：
        密码算法：hash，不可逆
        加密，解密：可逆
        消息摘要(message digest)：不可逆
            md5，message digest 第5，第4代容易被破解。
                只有32bit。
                32bit的16进制
            hash散列
                sha256：安全的256bit
                    64bit的16进制
            	ripeMd160：
            		160bit。
            		40bit的16进制

安全散列算法SHA（Secure Hash Algorithm）是美国国家安全局 （NSA） 设计，
美国国家标准与技术研究院（NIST） 发布的一系列密码散列函数，包括 SHA-1、SHA-224、
SHA-256、SHA-384 和 SHA-512 等变体。主要适用于数字签名标准（DigitalSignature
Standard DSS）里面定义的数字签名算法（Digital Signature Algorithm DSA）。
SHA-1已经不是那边安全了，google和微软都已经弃用这个加密算法。为此，我们使用热门的
比特币使用过的算法SHA-256作为实例。其它SHA算法，也可以按照这种模式进行使用。

            	为了短

            	base58编码：来源base64


    B：step4：
    创建创世区块：
        比特币中创世区块，是中本聪于2009年1月3日，中本聪开发出首个实现了比特币算法的客户端程序并进
        行了首次“采矿”（mining）。   北京时间2009年1月4日  2:15:05 AM(英国时间约2009年1月3日
          18:15:05 PM） 比特币的第一个区块，这就是创世区块产生。

        中本聪获得了第一批50个比特币。挖矿奖励比特币数并不是固定的，每产生21万个区块奖励就减半。
        截止到目前每挖到一个区块奖励为12.5个比特币。
        在第一个区块中，没有交易记录。而是将《泰晤士报》2009年1月3日的一条新闻永远记录在了其中。

    C：
        step5：BlockChain结构体，
        step6：创建带有创世区块的区块链
    D：向区块链中添加一个新的区块
        step7：


2.工作量证明
    挖矿：XXXXXXX。。。。
        挖矿的过程，就是个暴力破解的过程，需要算力。
        挖矿计算的hash，就是将这些值拼一起做一个hash，时间戳改变，nonce从0开始累加，不同的生成hash。
        用算出的hash和目标哈希匹配

        挖矿：每个矿机，分别分摊nonce。有一个计算成功就可以。瞬间验证，微秒级别。
        验证成功后，更新hash值，

        	矿机-->矿场-->矿池(跨国家)
        			矿池挖到框，根据算力，分配给每台矿机。
            CPU-GPU-专业挖矿及-矿厂-矿池

Difficulty：


bits：目标难度，16进制表示。
	某个时间段都是固定的。如果大家都在10分钟挖到，就一直固定。否则再修改。

	通过bits可以计算出目标Hash(固定的)，计算出的hash要小于目标hash，就相当于挖矿成功。

    计算机颠倒数据：防止前面是0。
    		大端排序-->小端排序
    			1个字节：2个数

    			  ● 难度Difficulty：
                      ○ 整个网络会通过调整“难度”这个变量来控制生成工作量证明所需要的计算力。
                      ○ 随着难度增加，矿工通常在循环便利4亿次随机数值后仍未找到区块，则会启用超额随机数。
                  ● 难度目标Bits:
                      ○ 使整个网络的计算力大致每10分钟产生一个区块所需要的难度数值即为难度目标。
                      ○ Bits是用来存储难度目标的16进制数值。
                      ○ 例如516532块：
                  1. Bits = "0x17502ab7"
                  2. coefficient系数，coefficient = 0x502ab7
                  3. exponent指数，exponent　= 0x17
                  4. target = coefficient * Math.pow(2, 8 * (exponent - 3))
                  5. 目标hash：000000000000000000502ab700000000d6420b16625d309c4561290000000000
                  6. 实际hash：00000000000000000041ff1cfc5f15f929c1a45d262f88e4db83680d90658c0c
                  7. Bits值越小，难度越大，越难挖矿。





    A：添加工作量证明
        删除setHash()方法
        step1，修改Block结构体
            添加Nonce（修改NewBlock()）
        step2:创建ProofOfWork结构体
        step3: 创建新的工作量证明对象NewProofOfWork()
        step4：返回有效的哈希和nonce值Run()-->hash([]byte),nonce(int64)
        step5：修改NewBlock()，设置有效的hash和nonce



    B：难度系数
    Difficulty：
        整个网路会通过调整"难度"这个变量来控制生成工作量证明所需要的算力
        随着难度系数的增加，矿工通常在循环遍历4亿次随机数后仍未找到区块，则会启动超额随机数
    Bits = "0x17502ab7"
        coefficient系数：
            coefficient = 0x502ab7
        exponent指数：
            exponent = 0x17
    target = coefficient * Math.pow(2, 8 * (exponent - 3))
    目标hash：000000000000000000502ab700000000d6420b16625d309c4561290000000000
    实际hash：00000000000000000041ff1cfc5f15f929c1a45d262f88e4db83680d90658c0c
        所以：Bit值越小，难度越大，挖矿越难。

    一般经过2016个区块后，bits的值就被调整一次。

        step1：修改ProofOfWork结构体，添加target
        step2：设置targetbits = 16
        step3：修改NewProofOfWork()
        step4：创建prepareData()，用于获取block对象的[]byte